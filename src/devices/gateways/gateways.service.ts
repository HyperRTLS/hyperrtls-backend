import { Injectable, NotFoundException } from '@nestjs/common';

import {
  EntityData,
  MikroORM,
  QBFilterQuery,
  QueryOrder,
  wrap,
} from '@mikro-orm/core';
import { EntityRepository } from '@mikro-orm/postgresql';
import { InjectRepository } from '@mikro-orm/nestjs';

import { GatewayEntity } from './gateway.entity';

import { GatewaysEventBus } from './gateways.eventBus';
import { DynamicSecurityService } from '../../nestjs-dynsec/dynsec.service';

type GetOptions = unknown;

type CreateGatewayData = {
  id: string;
  name: string;
  mqttPassword?: string;
};

@Injectable()
export class GatewaysService {
  constructor(
    private readonly orm: MikroORM,
    private readonly dynsecService: DynamicSecurityService,
    @InjectRepository(GatewayEntity)
    private readonly gatewayRepository: EntityRepository<GatewayEntity>,
    private readonly gatewaysEventBus: GatewaysEventBus,
  ) {}

  public get(filter?: QBFilterQuery<GatewayEntity>, _options?: GetOptions) {
    const qb = this.gatewayRepository.createQueryBuilder('a');

    if (filter) qb.where(filter);

    return qb.orderBy([{ id: QueryOrder.ASC }]).getResultList();
  }

  public async getOneById(id: string, options?: GetOptions) {
    const results = await this.get({ id }, options);

    if (results.length === 0) {
      throw new NotFoundException();
    }

    return results[0];
  }

  public async create(data: CreateGatewayData) {
    const newGateway = new GatewayEntity(data.id, data.name);
    await this.gatewayRepository.persistAndFlush(newGateway);

    await this.dynsecService.createRole({
      rolename: data.id,
      textname: data.name,
      textdescription: 'Role automatically generated by DynamicSecurityModule',
      acls: [
        {
          acltype: 'publishClientSend',
          topic: `gateways/${data.id}/#`,
          allow: true,
        },
        {
          acltype: 'publishClientReceive',
          topic: `gateways/${data.id}/#`,
          allow: true,
        },
        {
          acltype: 'subscribePattern',
          topic: `gateways/${data.id}/#`,
          allow: true,
        },
        {
          acltype: 'unsubscribePattern',
          topic: `gateways/${data.id}/#`,
          allow: true,
        },
      ],
    });

    await this.dynsecService.createClient({
      username: data.id,
      textname: data.name,
      textdescription:
        'Client automatically generated by DynamicSecurityModule',
      password: data.mqttPassword,
      roles: [
        {
          rolename: data.id,
        },
      ],
    });

    return newGateway;
  }

  public async deleteById(id: string) {
    const gatewayEntityReference = this.gatewayRepository.getReference(id);

    await this.dynsecService.deleteClient({ username: id });

    await this.dynsecService.deleteRole({ rolename: id });

    await this.gatewayRepository.removeAndFlush(gatewayEntityReference);
  }

  public async update(
    id: string,
    data: Pick<EntityData<GatewayEntity>, 'name'>,
  ) {
    const gatewayEntityReference = this.gatewayRepository.getReference(id);

    wrap(gatewayEntityReference).assign(data);

    await this.gatewayRepository.flush();
  }

  public getEventStream(filters?: {
    deviceIds?: Array<string>;
    eventTypes?: Array<string>;
  }) {
    return this.gatewaysEventBus.toObservable(filters);
  }
}
